# Week05

## 期中复习

- 五毒神掌
之前一直不太理解五毒神掌是个什么道理,后来通过在收纳蒙古包蚊帐和安装洗衣机上水龙头时顿悟了. 特别在安装水龙头时,刚开始自己琢磨了好久就是安装不对,总是漏水,经过搜索抖音原来还可以这样呀. `5分钟想不明白就去看题解` 在收纳蚊帐时,看了好多视频就是感觉不对,就不断的找其他的视频直到找到我能看懂得视频为止. `找到所有解题思路,并首先找到适合自己的.` 其次,死记硬背在刷算法题目有用,但是在收纳蚊帐时不好用. `如果你不能理解动作要领,就是会出bug,而且下次还会遇到同样的bug`

- 提升维度
超哥在讲跳表的时候,就说跳表的思想其实就是提升了一个维度来思考问题.也就是常说的`跳出来思考`.

- 分治
有些问题看起来很复杂,但是通过分解成一个一个小的任务之后,就会觉得会很简单;比如工作中的任务分解,年度计划拆解成月度计划等

- 知行合一
思想和行为统一,`光说不练假把式`. 学习算法,不仅仅只会做几个题目,更重要的是解决问题的思维方式和方法.

### 数据结构

- 一维
  - 数组,链表,跳表
  - 栈,队列,优先队列,双端队列
  - 哈希表,映射,集合
- 二维
  - 树,二叉树,二叉搜索树
  - 堆,二叉堆,图
- 其他

### 算法

- 递归
  - 泛型递归,树递归
  - 分治,回溯
- 搜索
  - 深度优先
  - 广度优先
  - A*
- 贪心算法
- 二分查找
- 动态规划

#### 数组,链表,跳表

- 数组
  - 内存中分配的连续内存,是手动一个一个申明变量的进步
  - 访问元素,尾部插入删除O(1), 其他都是O(n)
- 链表
  - 不用连续的内存,通过next指针指向下一个节点
  - 插入删除O(1),其他都是O(n)
- 跳表
  - 是一个有序的链表
  - 通过提升维度(类似加了个目录),增加搜索的速度,但空间成本和维护会成本提高

### 栈,队列,优先队列,双端队列

- 栈
  - 先进后出
  - 插入删除O(1)

- 队列
  - 先进先出
  - 插入删除O(1)

- 双端队列
  - 双边都可以进和出
  - 插入删除O(1)

- 优先队列
  - 按照优先级取出数据
  - 取出操作O(logN)
  - 一般用 heap,bst,treap实现

### 哈希表,映射,集合

- 哈希表(Hash table)
  - 也称散列表,根据关键码值(key value)访问数据
  - 一般增删改查都是O(1)

### 树,二叉树,二叉搜索树

- 树
  - 可以看做是链表的升级,next指向多个子节点,但是子节点有且只有一个父节点(也是没有环)

- 二叉树
  - 只有左右子节点的树

- 二叉搜索树
  - 左子树小于父节点,右子树大于父节点

- 二叉树遍历
  - 前序: 根-左-右(一般用于访问时立即需要执行)
  - 中序: 左-根-右(在二叉搜树可以用于排序)
  - 后序: 左-右-根(一般由于删除,例如删除所有文件夹里的文件)

### 堆,二叉堆,图

- 堆(Heap)
  - 能够在一堆数据中快速找到最大或最小值
  - find-max: O(1)
  - delete-max: O(logN)
  - create(insert): O(1) or O(logN)

- 二叉堆
  - 一颗完整的树
  - 其中任意节点总是>=其子节点
  - 一般通过数组实现
  - 父子之间对应的关系
    - 左 (2*i+1)
    - 右 (2*i+2)
    - 父 floor((i-1)/2)
  - insert插入操作
    - 自底向上
    - 步骤
      - 新增元素插入尾部
      - 跟父节点比较并交换,直到root或比父节点小位置
  - delete删除操作
    - 自顶向下
    - 步骤
      - 删除顶部元素,把末尾的元素补位
      - 然后跟左右子节点比较,跟较大的交换,直到比左右节点大或者没有子节点为止

- 图
  - 有换的树
  - Graph(V, E)
  - V-vertex: 点
    - 度: 入度和出度
    - 点与点之间: 连通与否
  - E-edge: 边
    - 有向和无向(单行线)
    - 权重(边长)
  - 基于图的常见算法
    - BFS
    - DFS

#### 算法手段

现在编程的主要手段有: 分支,循环,递归

- 递归
  - 找到最近的重复子问题, 可以通过数学归纳法的去寻找

- 分治
  - 把大的问题分解成小的问题,然后把小的问题合并得到最终结果

- 回溯
  - 分解大问题,并尝试每种可能情况,发现不行及时回撤选择另外的途径

- 搜索: 每个节点访问且只访问一次
  - 深度优先: 依次访问每个节点到最末端,再访问下一个
  - 广度优先: 一层一层的遍历

- 贪心算法
  - 首先问题可以分解,然后期望在每个问题得到最优解,从而获取全的最优解

- 二分查找
  - 可以加速, O(N) ---> O(logN)
  - 条件:
    - 目标函数具有单调性
    - 有上下边界
    - 可以被索引访问

- 动态规划
  - 分解大问题,找重复子问题;找到其中的最优解,淘汰次优解
